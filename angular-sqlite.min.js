!function(window,angular,undefined){"use strict";var SqliteCls=function($q,name,size,ver,desc,debug){var db,dbName=name,dbSize=size,dbVer=ver,dbDesc=desc,debugMode=debug,self=this,seriesTx=!1,connect=function(){var defer=$q.defer();return db===undefined||null===db?"phonegap"===dbVer?document.addEventListener("deviceready",function(){db=window.sqlitePlugin.openDatabase({name:dbName+".db",location:1}),defer.resolve(db)},!1):(db=window.openDatabase(dbName,dbVer,dbDesc,dbSize),defer.resolve(db)):defer.resolve(db),defer.promise},errorHandler=function(error,defer){defer.reject(error),debugMode===!0&&console.log("error:",error)},successHandler=function(results,defer){defer.resolve(results),debugMode===!0&&console.log("success:",results)},placeholder=function(i){for(var p=[],j=0;i>j;++j)p.push("?");return p.join(",")},execute=function(tx,sql,data,_defer){data=data||[];var defer=_defer||$q.defer();return tx.executeSql(sql,data,function(tx,results){successHandler(results,defer)},function(tx,error){errorHandler(error,defer)}),defer.promise},getKey=function(obj){for(var key in obj)return key},getTasks=function(tasks){var methods=["create","find","save","del","query"];if(!angular.isArray(tasks))throw"Expecting series parameter is an array";return tasks.map(function(task){if(angular.isObject(task)){var methodName=getKey(task);if(-1===methods.indexOf(methodName))throw"Unexpected "+methodName+" method call!";return function(callback){self[methodName].apply(task[methodName]).then(callback)}}if(angular.isFunction(task))return function(callback){task().then(callback)};throw"Unable to handle "+typeof _call+" type parameter!"})};this.parse=function(results,type){switch(type&&(type=type.toUpperCase()),type){case"INSERT":return results?results.insertId:null;case"UPDATE":case"DELETE":return results?results.rowsAffected:null;default:if(results){var i,len=results.rows.length,data=[];for(i=0;len>i;++i)data.push(results.rows.item(i));return data}}return null},this.createTable=function(name,params,overwrite){overwrite=overwrite||!0;var sql="CREATE TABLE ",fields=[];return overwrite&&(sql+=" IF NOT EXISTS "),sql+=name+" (",angular.forEach(params,function(value,key){fields.push(key+" "+value)}),sql+=fields.join(",")+")",self.query(sql)},this.getTransaction=function(rollback){var defer=$q.defer();return connect().then(function(db){db.transaction(function(tx){defer.resolve(tx)},rollback)}),defer.promise},this.listTables=function(){var defer=$q.defer(),sql="SELECT * FROM sqlite_master WHERE type=?";return self.query(sql,["table"]).then(function(results){debugMode&&console.log(results),defer.resolve(self.parse(results).filter(function(table){return"__"===table.name.substr(0,2)?!1:!0}))})["catch"](function(error){defer.reject(error)}),defer.promise},this.query=function(sql,data){data=data||[];var defer=$q.defer();return seriesTx!==!1?execute(seriesTx,sql,data,defer):self.getTransaction().then(function(tx){execute(tx,sql,data,defer)})["catch"](defer.reject),defer.promise},this.transaction=function(sqls,datas){var defer=$q.defer();return self.getTransaction(function(err){defer.reject({error:err,level:"transaction level error"})}).then(function(tx){var i,ctn=sqls.length,Ds=[];for(i=0;ctn>i;++i)Ds.push(execute(tx,sqls[i],datas[i]));$q.all(Ds).then(function(){defer.resolve(!0)})})["catch"](defer.reject),defer.promise},this.create=function(tableName,params){var defer=$q.defer(),sql="INSERT INTO "+tableName+"(",fields=[],data=[];return angular.forEach(params,function(value,field){fields.push(field),data.push(value)}),sql+=fields.join(",")+") VALUES ("+placeholder(data.length)+")",seriesTx!==!1?execute(seriesTx,sql,data,defer):self.query(sql,data).then(function(results){defer.resolve(self.parse(results,"INSERT"))})["catch"](function(error){defer.resolve(error)}),defer.promise},this.find=function(tableName,params){var defer=$q.defer(),sql="SELECT ",data=[];return params=params||{},sql+=params.fields?params.fields.join(","):" * ",sql+=" FROM "+tableName,params.groupby?(sql+=" GROUP BY "+params.groupby,params.having&&(sql+=" HAVING "+params.having)):params.where&&(sql+=" WHERE "+params.where),params.order&&(sql+=" ORDER BY "+params.order),params.limit&&(sql+=" LIMIT "+params.limit),seriesTx!==!1?execute(seriesTx,sql,data,defer):self.query(sql,data).then(function(result){defer.resolve(self.parse(result))})["catch"](function(error){defer.reject(error)}),defer.promise},this.save=function(tableName,params,where){var defer=$q.defer(),sql="UPDATE "+tableName+" SET ",fields=[],data=[];return angular.forEach(params,function(value,field){fields.push(field+"=?"),data.push(value)}),sql+=fields.join(","),where&&(sql+=" WHERE "+where),seriesTx!==!1?execute(seriesTx,sql,data,defer):self.query(sql,data).then(function(result){defer.resolve(self.parse(result,"UPDATE"))})["catch"](function(error){defer.reject(error)}),defer.promise},this.del=function(tableName,where,data){data=data||[];var defer=$q.defer(),sql="DELETE FROM "+tableName;return where&&(sql+=" WHERE "+where),seriesTx!==!1?execute(seriesTx,sql,data,defer):self.query(sql,data).then(function(result){defer.resolve(self.parse(result,"DELETE"))})["catch"](function(error){defer.reject(error)}),defer.promise},this.getOptions=function(){return{"database name":dbName,"database size":dbSize,"database version":dbVer,"database description":dbDesc,"debug mode":debugMode}},this.series=function(tasks){var defer=$q.defer();return self.getTransaction(function(err){defer.reject({errror:err,msg:"transaction level error from series"})}).then(function(tx){seriesTx=tx,async.series(getTasks(tasks),function(err,result){seriesTx=!1,err?defer.reject(err):defer.resolve(result)})}),defer.promise}},app=angular.module("nbSqlite",[]);app.provider("$nbSqlite",function(){var dbName="defaultDBName",dbSize=5242880,dbVersions=["1.0","phonegap"],dbVer="1.0",dbDesc="Angular Sqlite Database",debug=!1;this.config=function(name,debugMode,ver,size,desc){if(dbName=name||dbName,debug=debugMode||debug,dbSize=size||dbSize,dbDesc=desc||dbDesc,ver){if(-1===dbVersions.indexOf(ver))throw"The version your supplied "+ver+" is not support. Supported: ['1.0','phonegap']";dbVer=ver}},this.$get=["$q",function($q){return new SqliteCls($q,dbName,dbSize,dbVer,dbDesc,debug)}]})}(window,window.angular);